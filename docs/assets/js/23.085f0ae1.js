(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{393:function(a,e,o){"use strict";o.r(e);var r=o(29),s=Object(r.a)({},(function(){var a=this,e=a.$createElement,o=a._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[o("h1",{attrs:{id:"discussao-sobre-padroes-de-criacao"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#discussao-sobre-padroes-de-criacao"}},[a._v("#")]),a._v(" Discuss√£o sobre padr√µes de cria√ß√£o")]),a._v(" "),o("p",[a._v("Existem duas maneiras comuns de parametrizar um sistema pelas classes de objetos que ele cria. Uma √© criar subclasses da classe que cria os objetos; isto corresponde a usar o padr√£o "),o("a",{attrs:{href:"/gof/FactoryMethod"}},[a._v("Factory Method")]),a._v(". A principal desvantagem desta solu√ß√£o √© que requer a cria√ß√£o de uma nova subclasse somente para mudar a classe do produto. Tais mudan√ßas podem gerar uma cascata de modifica√ß√µes encadeadas. Por exemplo, quando o criador do produto √© ele pr√≥prio, criado por um m√©todo f√°brica, ent√£o voc√™ tem que redefinir tamb√©m o seu criador.")]),a._v(" "),o("p",[a._v("A outra forma de parametrizar um sistema baseia-se mais na composi√ß√£o de objetos: defina um objeto que seja respons√°vel por conhecer a classe dos objetos- produto e torne-o um par√¢metro do sistema. Este √©o aspecto-chave dos padr√µes "),o("a",{attrs:{href:"/gof/AbstractFactory"}},[a._v("Abstract Factory")]),a._v(", "),o("a",{attrs:{href:"/gof/Builder"}},[a._v("Builder")]),a._v("  e "),o("a",{attrs:{href:"/gof/Prototype"}},[a._v("Prototype")]),a._v(". Todos os tr√™s padr√µes envolvem a cria√ß√£o de um novo objeto-f√°brica cuja responsabilidade √© criar objetos-produtos. Em Abstract Factory, o objeto-f√°brica produz Objetos de v√°rias classes. Em Builder, um objeto-f√°brica constr√≥i incrementalmente um objeto complexo usando um protocolo igualmente complexo. O padr√£o Prototype faz o objeto-f√°brica construir um objeto-produto copiando um objeto protot√≠pico. Neste caso, o objeto-f√°brica e o prot√≥tipo s√£o o mesmo objeto, porque o prot√≥tipo √© respons√°vel por retornar o produto.")]),a._v(" "),o("p",[a._v("Considere o framework para um editor de desenhos descrito no padr√£o Prototype.\nH√° v√°rias maneiras de parametrizar uma GraphicTool pela classe do produto:")]),a._v(" "),o("ul",[o("li",[a._v("Aplicando-se o padr√£o FactoryMethod, uma subclasse de GraphicTool ser√° criada para cada subclasse de Graphic na paleta. A GraphicTool ter√° uma nova opera√ß√£o NewGraphic, que cada subclasse de GraphicTool redefinir√°.")]),a._v(" "),o("li",[a._v("Aplicando-se o padr√£o Abstract Factory, haver√° uma hierarquia de classes de GraphicsFactories, uma para cada subclasse de Graphic. Neste caso, cada f√°brica cria apenas o produto: CircleFactory criar√° c√≠rculos (Circles), LineFactory criar√° linhas (Lines), e assim por diante. Uma GraphicTool ser√° parametrizada como uma f√°brica para cria√ß√£o do tipo apropriado de Graphics.")]),a._v(" "),o("li",[a._v("Aplicando-se o padr√£o Prototype,cada subclasse de Graphics implementar√° a opera√ß√£o Clone, e uma GraphicTool ser√° parametrizada com um prot√≥- tipo da Graphic que ela cria.")])]),a._v(" "),o("p",[a._v("Definir qual √© o melhor padr√£o depende de muitos fatores. No nosso framework para editores de desenhos, o padr√£o Factory Method √© inicialmente mais f√°cil de usar. √â f√°cil definir uma subclasse de GraphicTool e as inst√¢ncias de GraphicTool s√£o criadas somente quando a paleta √© definida. Aqui, a principal desvantagem √© a prolifera√ß√£o de subclasses de GraphicTool, sendo que nenhuma delas faz muita coisa.")]),a._v(" "),o("p",[a._v("O padr√£o Abstract Factory n√£o oferece uma grande melhoria porque tamb√©m exige uma hierarquia de classes GraphicsFactory bastante grande. Abstract Factory seria prefer√≠vel a Factory Method somente se j√° houvesse uma hierarquia de classes GraphicsFactory‚Äî ou se o compilador a fornecesse automaticamente (como em Small- talk ou Objective C) ou se fosse necess√°ria em outra parte do sistema.")]),a._v(" "),o("p",[a._v("No geral, o padr√£o Prototype √© o melhor para o framework de editores de desenho porque ele somente requer a implementa√ß√£o de uma opera√ß√£o Clone em cada classe Graphics. Isso reduz o n√∫mero de classes, e clone pode ser usado para outras finalidades, al√©m de somente instancia√ß√£o (por exemplo, uma opera√ß√£o duplicar definida no menu).")]),a._v(" "),o("p",[a._v("O Factory Method torna um projeto mais adapt√°vel e apenas um pouco mais complicado. Outros padr√µes de projeto requerem novas classes, enquanto que Factory Method somente exige uma nova opera√ß√£o. As pessoas freq√ºentemente usam Factory Method como a maneira padr√£o de criar objetos, mas n√£o √© necess√°rio quando a classe que √© instanciada nunca muda ou quando a instancia√ß√£o ocorre em uma opera√ß√£o que subclasses podem facilmente redefinir, tal como uma opera√ß√£o de inicializa√ß√£o.")]),a._v(" "),o("p",[a._v("Projetos que usam Abstract Factory, Prototype ou Builder s√£o ainda mais flex√≠veis do que aqueles que utilizam Factory Method, por√©m, eles tamb√©m s√£o mais complexos. Freq√ºentemente, os projetos come√ßam usando Factory Method e evoluem para outros padr√µes de cria√ß√£o √† medida que o projetista descobre onde √© necess√°ria maior flexibilidade. O conhecimento de v√°rios padr√µes de projeto lhe d√° mais op√ß√µes quando trocar um crit√©rio de projeto por outro.")]),a._v(" "),o("h2",{attrs:{id:"factory-method-‚úÖ"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#factory-method-‚úÖ"}},[a._v("#")]),a._v(" "),o("a",{attrs:{href:"/gof/FactoryMethod"}},[a._v("Factory Method")]),a._v(" ‚úÖ")]),a._v(" "),o("ul",[o("li",[a._v("Definir uma interface para criar um objeto mas deixar que subclasses decidam que classe instanciar")])]),a._v(" "),o("h2",{attrs:{id:"abstract-factory-‚úÖ"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#abstract-factory-‚úÖ"}},[a._v("#")]),a._v(" "),o("a",{attrs:{href:"/gof/AbstractFactory"}},[a._v("Abstract Factory")]),a._v(" ‚úÖ")]),a._v(" "),o("ul",[o("li",[a._v("Prover interface para criar fam√≠lias de objetos relacionados ou dependentes sem especificar suas classes concretas")])]),a._v(" "),o("h2",{attrs:{id:"builder-üöß"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#builder-üöß"}},[a._v("#")]),a._v(" Builder üöß")]),a._v(" "),o("ul",[o("li",[a._v("Separar a constru√ß√£o de objeto complexo da representa√ß√£o para criar representa√ß√µes diferentes com mesmo processo")])]),a._v(" "),o("h2",{attrs:{id:"prototype-üöß"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#prototype-üöß"}},[a._v("#")]),a._v(" Prototype üöß")]),a._v(" "),o("ul",[o("li",[a._v("Especificar tipos a criar usando uma inst√¢ncia como prot√≥tipo e criar novos objetos ao copiar este prot√≥tipo")])]),a._v(" "),o("h2",{attrs:{id:"singleton-üî®"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#singleton-üî®"}},[a._v("#")]),a._v(" "),o("a",{attrs:{href:"/gof/Singleton"}},[a._v("Singleton")]),a._v(" üî®")]),a._v(" "),o("ul",[o("li",[a._v("Garantir que uma classe s√≥ tenha uma √∫nica inst√¢ncia, e prover um ponto de acesso global a ela")])])])}),[],!1,null,null,null);e.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{394:function(e,a,n){"use strict";n.r(a);var o=n(29),t=Object(o.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"bridge-gof"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bridge-gof"}},[e._v("#")]),e._v(" {Bridge} (GOF)")]),e._v(" "),n("p",[e._v("Desacoplar uma abstração da sua implementação, de modo que as duas possam variar\nindependentemente.")]),e._v(" "),n("h2",{attrs:{id:"tambem-conhecido-como"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tambem-conhecido-como"}},[e._v("#")]),e._v(" Também conhecido como")]),e._v(" "),n("p",[e._v("Handle/Body")]),e._v(" "),n("h2",{attrs:{id:"intencao"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#intencao"}},[e._v("#")]),e._v(" Intenção")]),e._v(" "),n("p",[e._v("Separar a construção de um objeto complexo da sua representação de modo que o mesmo processo de construção possa criar diferentes representações.")]),e._v(" "),n("h2",{attrs:{id:"motivacao"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivacao"}},[e._v("#")]),e._v(" Motivação")]),e._v(" "),n("p",[e._v("Quando uma abstração pode ter uma entre várias implementações possíveis, a maneira\nusual de acomodá-las é usando a herança. Uma classe abstrata define a interface para\na abstração, e subclasses concretas a implementam de formas diferentes. Mas essa\nabordagem nem sempre é suficientemente flexível. A herança liga uma implementação\nà abstração permanentemente, o que torna difícil modificar, aumentar e reutilizar\nabstrações e implementações independentemente.\nConsidere a implementação de uma Janela portável em um toolkit para construir\ninterfaces de usuários. Por exemplo, essa abstração deveria nos habilitar a escrever\naplicações que trabalham tanto com o sistema XWindow quanto com o Presentation-\nManager (PM), da IBM. Usando a herança, poderíamos definir uma classe abstrata\nWindow e subclasses XWindow e PMWindow que implementam a interface Janela\npara diferentes plataformas. Porém, essa abordagem tem dois problemas:")]),e._v(" "),n("ol",[n("li",[e._v("É inconveniente estender a abstração Window para cobrir diferentes tipos de janela ou novas plataformas. Imagine uma subclasse IconWindow de Window que especializa a abstração Window para ícones. Para suportar IconWindows para ambas as plataformas, temos que implementar duas classes novas, XIconWindow e PMIconWindow. Pior ainda, teremos que definir duas classes para cada tipo de janela. Suportar uma terceira plataforma exige ainda uma outra subclasse de Window para cada tipo de janela.")])]),e._v(" "),n("figure",[n("p",[n("img",{attrs:{src:"img/bridg098.gif",alt:""}})])]),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[e._v("Ela torna o código do cliente dependente de plataforma. Sempre que um cliente cria uma janela, instancia uma classe concreta que tem uma implementação específica. Por exemplo, a criação de um objeto Xwindow amarra a abstração Window à implementação do XWindow, o que torna o código do cliente dependente da implementação do XWindow. Isso, por sua vez, torna mais difícil portar o código do cliente para outras plataformas.\nOs clientes deveriam ser capazes de criar uma janela sem se prenderem a uma implementação concreta. Somente a implementação da janela deveria depender da plataforma na qual a aplicação é executada. Portanto, o código do cliente deveria instanciar janelas sem mencionar plataformas específicas.")])]),e._v(" "),n("p",[e._v("O padrão Bridge trata desses problemas colocando a abstração Window e sua implementação em hierarquias de classes separadas. Existe somente uma hierarquia de classes para interfaces de janelas (Window, IconWindow, TransientWindow) e uma hierarquia separada para implementações de janelas específicas das plataformas, tendo como sua raiz WindowImp. Por exemplo, a subclasse XWindowImp fornece uma implementação baseada no sistema XWindow.")]),e._v(" "),n("figure",[n("p",[n("img",{attrs:{src:"img/bridg100.gif",alt:""}})])]),e._v(" "),n("p",[e._v("Todas as operações das subclasses de Window são implementadas em termos das operações abstratas da interface WindowImp. Isso desacopla as abstrações de janelas das várias implementações específicas para cada plataforma. Referimo-nos ao relacionamento entre Window e WindowImp como uma ponte (bridge) porque ela forma uma ponte entre abstração e sua implementação, permitindo que variem de forma independente.")]),e._v(" "),n("h2",{attrs:{id:"aplicabilidade"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#aplicabilidade"}},[e._v("#")]),e._v(" Aplicabilidade")]),e._v(" "),n("p",[e._v("Use o padrão Bridge quando:")]),e._v(" "),n("p",[e._v("• desejar evitar um vínculo permanente entre uma abstração e sua implementação.\nIsso pode ocorrer, por exemplo, quando a implementação deve ser selecionada ou alterada em tempo de execução;")]),e._v(" "),n("p",[e._v("• tanto as abstrações como suas implementações tiverem de ser extensíveis por meio de subclasses. Neste caso, o padrão Bridge permite combinar as diferentes abstrações e implementações e estendê-las independentemente;")]),e._v(" "),n("p",[e._v("• mudanças na implementação de uma abstração não puderem ter impacto sobre os clientes; ou seja, quando o código dos mesmos não puder ser recompilado.")]),e._v(" "),n("p",[e._v("• (C++) você desejar ocultar completamente a implementação de uma abstração dos clientes. Em C++, a representação de uma classe é visível na interface da classe;")]),e._v(" "),n("p",[e._v("• tiver uma proliferação de classes, como foi mostrado no primeiro diagrama da seção Motivação. Tal hierarquia de classes indica necessidade de separar um objeto em duas partes. Rumbaugh usa o termo “generalizações aninhadas” (nested generalizations) [RPB+91] para se referir às hierarquias de cada classe;")]),e._v(" "),n("p",[e._v("• desejar compartilhar uma implementação entre múltiplos objetos (talvez usando\na contagem de referências) e este fato deve estar oculto do cliente. Um exemplo\nsimples é a classe String mencionada por Coplien [Cop92], na qual múltiplos\nobjetos podem compartilhar a mesma representação de uma string (StringRep).")]),e._v(" "),n("h2",{attrs:{id:"estrutura"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#estrutura"}},[e._v("#")]),e._v(" Estrutura")]),e._v(" "),n("figure",[n("p",[n("img",{attrs:{src:"img/bridge.gif",alt:""}})])]),e._v(" "),n("h2",{attrs:{id:"participantes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#participantes"}},[e._v("#")]),e._v(" Participantes")]),e._v(" "),n("p",[e._v("• Abstraction (Window)\n– define a interface da abstração;\n– mantém uma referência para um objeto do tipo Implementor.")]),e._v(" "),n("p",[e._v("• RefinedAbstraction (IconWindow).\n– estende a interface definida por Abstraction.")]),e._v(" "),n("p",[e._v("• Implementor (WindowImp)\n– define a interface para as classes de implementação. Essa interface não\nprecisa corresponder exatamente à interface de Abstraction; de fato, as\nduas interfaces podem ser bem diferentes. A interface de Implementor\nfornece somente operações primitivas e Abstraction define operações de\nnível mais alto baseadas nessas primitivas.")]),e._v(" "),n("p",[e._v("• ConcreteImplementor (XwindowImp, PMWindowImp)\n– implementa a interface de Implementor e define sua implementação concreta.")]),e._v(" "),n("h2",{attrs:{id:"colaboracoes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#colaboracoes"}},[e._v("#")]),e._v(" Colaborações")]),e._v(" "),n("p",[e._v("• Abstraction repassa as solicitações dos clientes para o seu objeto Implementor.")]),e._v(" "),n("h2",{attrs:{id:"consequencias"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#consequencias"}},[e._v("#")]),e._v(" Consequências")]),e._v(" "),n("p",[e._v("O padrão Bridge tem as seguintes conseqüências:")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("Desacopla a interface da implementação. Uma implementação não fica permanentemente presa a uma interface. A implementação de uma abstração pode\nser configurada em tempo de execução. É até mesmo possível para um objeto\nmudar sua implementação em tempo de execução.\nO desacoplamento de Abstraction e Implementor também elimina dependências\nem tempo de compilação da implementação. Mudar uma classe de\nimplementação não requer a recompilação da classe Abstraction e seus\nclientes. Essa propriedade é essencial quando você quer assegurar compatibilidade\nno nível binário entre diferentes versões de uma biblioteca de\nclasses.\nAlém disso, esse desacoplamento encoraja o uso de camadas que podem\nmelhorar a estruturação de um sistema. A parte de alto nível de um sistema\nsomente tem que ter conhecimento de Abstraction e Implementor.")])]),e._v(" "),n("li",[n("p",[e._v("Extensibilidade melhorada. Você pode estender as hierarquias de Abstraction\ne Implementor independentemente.")])]),e._v(" "),n("li",[n("p",[e._v("Ocultação de detalhes de implementação dos clientes. Você pode proteger e isolar\nos clientes de detalhes de implementação, tais como o compartilhamento de\nobjetos Implementor e o mecanismo de contagem de referências que os\nacompanham (se houver).")])])]),e._v(" "),n("h2",{attrs:{id:"implementacao"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#implementacao"}},[e._v("#")]),e._v(" Implementação")]),e._v(" "),n("p",[e._v("Considere os seguintes aspectos de implementação quando aplicar o padrão Bridge:")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("Há somente um Implementor. Em situações onde há somente uma\nimplementação, não é necessário criar uma classe abstrata Implementor.\nTrata-se aqui de um caso degenerado do padrão Bridge; existe uma relação um\npara um entre Abstraction e Implementor. Não obstante, essa separação ainda\né útil quando uma mudança na implementação numa classe não deve afetar\nseus clientes existentes – ou seja, não deveriam ser recompilados, apenas\n“linkeditadas” novamente. Carolan [CAR89] usa o termo “Cheshire Cat”, para\ndescrever esta separação. Em C++, a interface da classe Implementor pode ser\ndefinida num arquivo header privado, o qual não é fornecido aos clientes. Isso\npermite ocultar completamente uma implementação de uma classe dos seus\nclientes.")])]),e._v(" "),n("li",[n("p",[e._v("Criar o objeto Implementor correto. Como, quando e onde você decide qual\nclasse Implementor instanciar, se existe mais do que uma?\nSe a Abstraction tem conhecimento de todas as classes ConcreteImplementor,\nentão pode instanciar uma delas no seu constructor; pode decidir por uma\ndelas através de parâmetros passados para o seu constructor. Se, por exemplo,\numa classe da categoria coleção suporta múltiplas implementações, a\ndecisão pode se basear no tamanho da coleção. Uma implementação com uma lista ligada pode ser usada para coleções pequenas, e uma tabela de\nrandomização (hash table) para coleções maiores.\nUma outra abordagem é escolher, inicialmente, uma implementação-padrão e\nmudá-la mais tarde, de acordo com a utilização. Por exemplo, se a coleção\ncresce além de um certo limiar, então ela muda sua implementação para uma\nmais apropriada, para um número maior de itens.\nÉ possível também delegar totalmente a decisão para outro objeto. No exemplo\nWindow/WindowImp, nós podemos introduzir um objeto-fábrica (ver Abstract\nFactory (95)) cuja única função é encapsular aspectos específicos de plataformas.\nA fábrica sabe que tipo de objeto WindowImp criar para a plataforma em\nuso; uma Window simplesmente solicita isso para uma WindowImp, e esta\nretorna o tipo correto. Um benefício dessa abordagem é que a Abstraction não\nestá acoplada diretamente a nenhuma das classes Implementor.")])]),e._v(" "),n("li",[n("p",[e._v("Compartilhando Implementors. Coplien ilustra como a expressão Handle/\nBody em C++ pode ser usado para compartilhar implementações entre\nvários objetos [Cop92]. O Body armazena um contador de referências que a\nclasse Handle incrementa e decrementa. O código para atribuir handles com\nbodies compartilhados têm a seguinte forma geral:")])])]),e._v(" "),n("code-block",[n("p",[e._v("Handle &Handle::operator=(const Handle &other)\n{\nother._body->Ref();\n_body->Unref();")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("if (_body->RefCount() == 0)\n{\n    delete _body;\n}\n_body = other._body;\n\nreturn *this;\n")])])]),n("p",[e._v("}")])]),e._v(" "),n("ol",{attrs:{start:"4"}},[n("li",[e._v("Utilização de herança múltipla. Você pode usar a herança múltipla em C++ para combinar uma interface com a sua implementação [Mar91]. Por exemplo, uma classe pode herdar publicamente de Abstraction e privadamente de um ConcreteImplementor.Porém, porque esta abordagem usa herança estática, ela liga uma implementação permanentemente à sua interface. Portanto, você não pode implementar um autêntico padrão Bridge com herança múltipla – pelo menos não em C++.")])]),e._v(" "),n("h2",{attrs:{id:"exemplo-de-codigo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#exemplo-de-codigo"}},[e._v("#")]),e._v(" Exemplo de código")]),e._v(" "),n("h3",{attrs:{id:"exemplo-gof"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#exemplo-gof"}},[e._v("#")]),e._v(" Exemplo GOF")]),e._v(" "),n("p",[e._v("O código C++ a seguir implementa o exemplo Window/WindowImp da seção Motivação.\nA classe Window define a abstração de janela para aplicações de clientes:")]),e._v(" "),n("code-block",[n("p",[e._v("class Window {\npublic:\nWindow(View* contents);")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    // requests handled by window\n    virtual void DrawContents();\n\n    virtual void Open();\n    virtual void Close();\n    virtual void Iconify();\n    virtual void Deiconify();\n\n    // requests forwarded to implementation\n    virtual void SetOrigin(const Point& at);\n    virtual void SetExtent(const Point& extent);\n    virtual void Raise();\n    virtual void Lower();\n\n    virtual void DrawLine(const Point&, const Point&);\n    virtual void DrawRect(const Point&, const Point&);\n    virtual void DrawPolygon(const Point[], int n);\n    virtual void DrawText(const char*, const Point&);\n\nprotected:\n    WindowImp* GetWindowImp();\n    View* GetView();\n\nprivate:\n    WindowImp* _imp;\n    View* _contents; // the window's contents\n};\n")])])])]),e._v(" "),n("p",[e._v("Window mantém uma referência para uma WindowImp, a classe abstrata que\ndeclara uma interface para o sistema de janelas subjacente.")]),e._v(" "),n("code-block",[n("p",[e._v("class WindowImp {\npublic:\nvirtual void ImpTop() = 0;\nvirtual void ImpBottom() = 0;\nvirtual void ImpSetExtent(const Point&) = 0;\nvirtual void ImpSetOrigin(const Point&) = 0;")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    virtual void DeviceRect(Coord, Coord, Coord, Coord) = 0;\n    virtual void DeviceText(const char*, Coord, Coord) = 0;\n    virtual void DeviceBitmap(const char*, Coord, Coord) = 0;\n    // lots more functions for drawing on windows...\nprotected:\n    WindowImp();\n};\n")])])])]),e._v(" "),n("p",[e._v("As subclasses de Window definem os diferentes tipos de janelas que a aplicação\npode usar, tais como janelas de aplicação, ícones, janelas transitórias para diálogos, palettes flutuantes de ferramentas, e assim por diante.\nPor exemplo, a ApplicationWindow implementará a DrawContents para desenhar\na instância de View por ela armazenada:")]),e._v(" "),n("code-block",[n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("class ApplicationWindow : public Window {\npublic:\n    // ...\n    virtual void DrawContents();\n};\n\nvoid ApplicationWindow::DrawContents () {\n    GetView()->DrawOn(this);\n}\n")])])])]),e._v(" "),n("p",[e._v("IconWindow armazena o nome de um mapa de bits para o ícone que ela exibe...")]),e._v(" "),n("code-block",[n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("class IconWindow : public Window {\npublic:\n    // ...\n    virtual void DrawContents();\nprivate:\n    const char* _bitmapName;\n};\n")])])])]),e._v(" "),n("p",[e._v("... e implementa os DrawContents para desenhar um mapa de bits na janela:")]),e._v(" "),n("code-block",[n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("void IconWindow::DrawContents() {\n    WindowImp* imp = GetWindowImp();\n    if (imp != 0) {\n        imp->DeviceBitmap(_bitmapName, 0.0, 0.0);\n    }\n}\n")])])])]),e._v(" "),n("p",[e._v("São possíveis muitas outras variações de Window. Uma TransientWindow pode\nnecessitar se comunicar com a janela criada por ela durante o diálogo; daí manter uma referência para aquela janela. Uma PalleteWindow sempre flutua acima de outras\njanelas. Uma IconDockWindow contém IconWindows e as arranja de maneira ordenada.\nAs operações de Window são definidas em termos da interface de WindowImp. Por\nexemplo, a DrawRect extrai quatro coordenadas dos seus dois parâmetros Point antes\nde chamar a operação de WindowImp que desenha o retângulo na janela:")]),e._v(" "),n("code-block",[n("p",[e._v("void Window::DrawRect(const Point& p1, const Point& p2) {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    WindowImp* imp = GetWindowImp();\n\n    imp->DeviceRect(p1.X(), p1.Y(), p2.X(), p2.Y());\n\n}\n")])])])]),e._v(" "),n("p",[e._v("As subclasses concretas de WindowImp suportam diferentes sistemas de janelas.\nA subclasse XWindowImp suporta o sistema XWindow:")]),e._v(" "),n("code-block",[n("p",[e._v("class XWindowImp : public WindowImp {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public:\n    XWindowImp();\n\n    virtual void DeviceRect(Coord, Coord, Coord, Coord);\n    // remainder of public interface...\nprivate:\n    // lots of X window system-specific state, including:\n    Display* _dpy;\n    Drawable _winid;  // window id\n    GC _gc;           // window graphic context\n};    \n")])])])]),e._v(" "),n("p",[e._v("Para o PresentationManager (PM), nós definimos uma classe PMWindowImp:")]),e._v(" "),n("code-block",[n("p",[e._v("class PMWindowImp : public WindowImp {\npublic:\nPMWindowImp();\nvirtual void DeviceRect(Coord, Coord, Coord, Coord);")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("    // remainder of public interface...\nprivate:\n    // lots of PM window system-specific state, including:\n    HPS _hps;\n};    \n")])])])]),e._v(" "),n("p",[e._v("Estas subclasses implementam operações de WindowImp em termos do sistema de\njanelas primitivo. Por exemplo, DeviceRect é implementada para X como segue:")]),e._v(" "),n("code-block",[n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("void XWindowImp::DeviceRect (\n\n    Coord x0, Coord y0, Coord x1, Coord y1\n\n) {\n    int x = round(min(x0, x1));\n    int y = round(min(y0, y1));\n    int w = round(abs(x0 - x1));\n    int h = round(abs(y0 - y1));\n    XDrawRectangle(_dpy, _winid, _gc, x, y, w, h);\n}    \n")])])])]),e._v(" "),n("p",[e._v("A implementação para o PM pode se assemelhar ao seguinte:")]),e._v(" "),n("code-block",[n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("void PMWindowImp::DeviceRect (\n \n   Coord x0, Coord y0, Coord x1, Coord y1 ) \n\n   {\n    Coord left = min(x0, x1);\n    Coord right = max(x0, x1);\n    Coord bottom = min(y0, y1);\n    Coord top = max(y0, y1);\n\n    PPOINTL point[4];\n\n    point[0].x = left;    point[0].y = top;\n    point[1].x = right;   point[1].y = top;\n    point[2].x = right;   point[2].y = bottom;\n    point[3].x = left;    point[3].y = bottom;\n\n    if (\n        (GpiBeginPath(_hps, 1L) == false) ||\n        (GpiSetCurrentPosition(_hps, &point[3]) == false) ||\n        (GpiPolyLine(_hps, 4L, point) == GPI_ERROR)  ||\n        (GpiEndPath(_hps) == false)\n    ) {\n        // report error\n\n    } else {\n        GpiStrokePath(_hps, 1L, 0L);\n    }\n}\n")])])])]),e._v(" "),n("p",[e._v("Como uma janela obtém uma instância da subclasse correta de WindowImp? Neste\nexemplo, assumiremos que Window tem essa responsabilidade. A sua operação GetWindowImp obtém a instância correta de uma fábrica abstrata (ver Abstract Factory (95)) que efetivamente encapsula todos os aspectos específicos do sistema de janelas.")]),e._v(" "),n("code-block",[n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("WindowImp* Window::GetWindowImp () {\n    if (_imp == 0) {\n        _imp = WindowSystemFactory::Instance()->MakeWindowImp();\n    }\n    return _imp;\n}    \n")])])])]),e._v(" "),n("p",[e._v("O método WindowSystemFactory::Instance () retorna uma fábrica abstrata que manufatura todos os objetos específicos do sistema de janelas. Para simplificar, nós o tornaremos um Singleton (130) e deixaremos a classe Window acessar a fábrica diretamente.")]),e._v(" "),n("h3",{attrs:{id:"exemplo-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#exemplo-2"}},[e._v("#")]),e._v(" Exemplo 2")]),e._v(" "),n("figure",[n("p",[e._v("skinparam style strictuml\nhide empty members\ntitle Bridge Report File")]),e._v(" "),n("p",[e._v("abstract Report <"),n("abstract",[e._v("> {\nFile file\ngenerateReport()\ngenerateFile()"),n("br"),e._v("\n}")])],1),e._v(" "),n("p",[e._v("abstract File <"),n("abstract",[e._v(">{"),n("br"),e._v("\ngenerateFile()\n}")])],1),e._v(" "),n("p",[e._v('class "BasicReport" as B\nclass B {\ngenerateReport()\ngenerateFile()\n}')]),e._v(" "),n("p",[e._v('class "CompleteReport" as C\nclass C {\ngenerateReport()\ngenerateFile()')]),e._v(" "),n("p",[e._v("}")]),e._v(" "),n("p",[e._v('class "PDFFile" as PDF\nclass PDF {\ngenerateFile()')]),e._v(" "),n("p",[e._v("}")]),e._v(" "),n("p",[e._v('class "CSVFile" as CSV\nclass CSV {\ngenerateFile()')]),e._v(" "),n("p",[e._v("}")]),e._v(" "),n("p",[e._v("File --o Report")]),e._v(" "),n("p",[e._v("B -up-|> Report\nC -up-|> Report")]),e._v(" "),n("p",[e._v("CSV -up-|> File\nPDF -up-|> File")]),e._v(" "),n("figcaption",[e._v("Diagrama Bridge - Exemplo 2.")])]),e._v(" "),n("code-group",{attrs:{title:"Java"}},[n("p",[e._v("public class Client {\npublic static void main(String[] args) {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('\tProduct product = new Product("Teste", "teste1", 50, 13.5, 20);\n\n\tReport report1 = new CompleteReport(new PDFFile(), product);\n\treport1.generateReport();\n\tReport report2 = new BasicReport(new PDFFile(), product);\n\treport2.generateReport();\n\n\tReport report3 = new BasicReport(new CSVFile(), product);\n\treport3.generateReport();\n}\n')])])]),n("p",[e._v("}")]),e._v(" "),n("p",[e._v("public abstract class Report {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("protected File file;\nprotected Product product;\n\npublic Report(File f, Product product) {\n\tthis.file = f;\n\tthis.product = product;\n}\n\npublic void createFile(String report ) {\n\tfile.generateFile(report);\n}\n\n\npublic abstract void generateReport();\n")])])]),n("p",[e._v("}")]),e._v(" "),n("p",[e._v("public class BasicReport extends Report {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('public BasicReport(File file, Product product) {\n\tsuper(file, product);\n}\n\n@Override\npublic void generateReport() {\n\t\n\tStringBuilder builder = new StringBuilder();\n\tbuilder.append("Marca: ").append(product.getBrand()).append("\\n")\n\t\t.append("Tipo: ").append(product.getType()).append("\\n")\n\t\t.append("Quantidade: ").append(product.getAmount()).append("\\n");\n\n\n\tcreateFile(builder.toString());\n\n}\n')])])]),n("p",[e._v("}")]),e._v(" "),n("p",[e._v("public class CompleteReport extends Report {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('public CompleteReport(File file, Product product) {\n\tsuper(file, product);\n}\n\n@Override\npublic void generateReport() {\n\n\tStringBuilder builder = new StringBuilder();\n\tbuilder.append("Marca: ").append(product.getBrand()).append("\\n")\n\t\t\t.append("Tipo: ").append(product.getType()).append("\\n")\n\t\t\t.append("Quantidade: ").append(product.getAmount()).append("\\n")\n\t\t\t.append("Valor: ").append(product.getValue()).append("\\n")\n\t\t\t.append("Total de vendas: ").append(product.getAmountSales()).append("\\n")\n\t\t\t.append("Valor total de vendas: ").append(product.getValue() * product.getAmountSales()).append("\\n");\n\n\tcreateFile(builder.toString());\n\n}\n')])])]),n("p",[e._v("}")]),e._v(" "),n("p",[e._v("public interface File {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("void generateFile(String report);\n")])])]),n("p",[e._v("}")]),e._v(" "),n("p",[e._v("public class PDFFile implements File {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('@Override\npublic void generateFile(String report) {\n\tSystem.out.println("PDF \\n" + report);\n}\n')])])]),n("p",[e._v("}")]),e._v(" "),n("p",[e._v("public class CSVFile implements File {")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('@Override\npublic void generateFile(String report) {\n\tSystem.out.println("CSV \\n" + report);\n}\n')])])]),n("p",[e._v("}")]),e._v(" "),n("p",[e._v("public class Product {\nprivate String brand;\nprivate String type;\nprivate int amount;\nprivate double value;\nprivate int amountSales;")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public Product(String brand, String type, int amount, double value, int amountSales) {\n\tthis.brand = brand;\n\tthis.type = type;\n\tthis.amount = amount;\n\tthis.value = value;\n\tthis.amountSales = amountSales;\n}\n\n\npublic String getBrand() {\n\treturn this.brand;\n}\n\npublic void setBrand(String brand) {\n\tthis.brand = brand;\n}\n\npublic String getType() {\n\treturn this.type;\n}\n\npublic void setType(String type) {\n\tthis.type = type;\n}\n\npublic void setAmount(int amount) {\n\tthis.amount = amount;\n}\n\npublic void setValue(double value) {\n\tthis.value = value;\n}\n\npublic int getAmount() {\n\treturn this.amount;\n}\n\npublic double getValue() {\n\treturn this.value;\n}\n\npublic int getAmountSales() {\n\treturn this.amountSales;\n}\n")])])]),n("p",[e._v("}")])]),e._v(" "),n("h2",{attrs:{id:"usos-conhecidos"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usos-conhecidos"}},[e._v("#")]),e._v(" Usos conhecidos")]),e._v(" "),n("p",[e._v("O exemplo de Window acima provém da ET++ [WGM88]. Em ET++, a WindowImp é\nchamada de “WindowPort” e tem subclasses como XWindowPort e SunWindowPort.\nO objeto Window cria o seu correspondente Implementor solicitando-o de uma fábrica\nabstrata chamada “WindowSystem”. WindowSystem fornece uma interface para\ncriação de objetos específicos da plataforma, tais como fontes tipográficas, cursores, mapas de bits e assim por diante.")]),e._v(" "),n("p",[e._v("O projeto da ET++ de Window/WindowPort estende o padrão Bridge no sentido\nde que WindowPort também mantém uma referência de volta para a Window. A\nclasse implementor de WindowPort usa essa referência para notificar Window sobre\neventos específicos de WindowPort: a chegada de eventos de entrada, redimensionamento de janelas, etc.")]),e._v(" "),n("p",[e._v("Tanto Coplien [Cop92] como Stroustrup [Str91] mencionam classes Handle e\ndão alguns exemplos. Seus exemplos enfatizam tópicos de administração da memória,\ntais como compartilhamento de representações de “strings”, e suporte para\nobjetos de tamanho variável. Nosso foco está mais em suportar extensões independentes, tanto de abstrações quanto de suas implementações.")]),e._v(" "),n("p",[e._v("libg++[Lea88] define classes que implementam estruturas de dados comuns,\ntais como Set, LinkedSet, HashSet, LinkedList e HashTable. Set é uma classe abstrata que define uma abstração de um conjunto, enquanto que LinkedList e HashTable são implementadores concretos (concrete implementors) para uma lista ligada e uma tabela de randomização, respectivamente. LinkedSet e HashSet são implementadores que fazem uma ponte entre Set e seus correspondentes concretos LinkedList e HashTable. Esse é um exemplo de um padrão Bridge degenerado porque não há uma classe abstrata Implementor.")]),e._v(" "),n("p",[e._v("O AppKit, da NeXT, [Add94] usa o padrão Bridge na implementação e exibição\nde imagens gráficas. Uma imagem pode ser representada de diversas maneiras. A\nforma de exibição ótima de uma imagem depende das propriedades do dispositivo\nde display, especificamente de suas capacidades quanto a cores e resolução. Sem a\najuda do AppKit, os desenvolvedores teriam que determinar qual seria a implementação a ser usada sob várias circunstâncias em cada aplicação.")]),e._v(" "),n("p",[e._v("Para aliviar os desenvolvedores desta responsabilidade, a AppKit fornece uma\nbridge (ponte) chamada NXImage/NXImageRep. NXImage define a interface para a\nmanipulação de imagens. A implementação de imagens é definida numa hierarquia\nde classes separada NXImageRep, a qual tem subclasses, tais como NXEPSImageRep,\nNXCachedImageRep e NXBitMapImageRep. NXImage mantém uma referência para\num ou mais objetos NXImageRep. Se existe mais do que uma implementação de\nimagem, então NXImage seleciona a mais adequada para o dispositivo de display que\nestá sendo usado. NXImage é até mesmo capaz de converter de uma implementação\npara outra, se necessário.")]),e._v(" "),n("p",[e._v("O aspecto interessante dessa variante do Bridge, é que NXImage pode armazenar\nmais do que uma implementação NXImageRep ao mesmo tempo.")]),e._v(" "),n("h2",{attrs:{id:"padroes-relacionados"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#padroes-relacionados"}},[e._v("#")]),e._v(" Padrões relacionados")]),e._v(" "),n("p",[e._v("Um padrão Abstract Factory (95) pode criar e configurar uma Bridge específica.\nO padrão Adapter (140) é orientado para fazer com que classes não-relacionadas\ntrabalhem em conjunto. Ele é normalmente aplicado a sistemas que já foram projetados.\nPor outro lado, Bridge é usado em um projeto, desde o início, para permitir que\nabstrações e implementações possam variar independentemente.")]),e._v(" "),n("h2",{attrs:{id:"referencias"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#referencias"}},[e._v("#")]),e._v(" Referências")])],1)}),[],!1,null,null,null);a.default=t.exports}}]);